```
namespace MCRunner.Instruments
{
    public enum BarType
    {
        Live,
        Historic
    }

    public struct Bar
    {
        public DateTime Time;
        public double High;
        public double Low;
        public double Open;
        public double Close;
        public double Volume;
        public BarType BarType;
    }
}
```
```
namespace MCRunner.Instruments
{
    public class BarSeries<T> : ISeries<T>
    {
        private IList<Bar> Bars { get; }
        private FieldInfo Field { get; }

        private readonly Type type = typeof(T);

        public T this[int barsAgo]
        {
            get
            {
                if (barsAgo < 0)
                {
                    throw new IndexOutOfRangeException("Can't look into the future!");
                }

                var count = Bars.Count;
                var index = count - 1 - barsAgo;
                
                if (index < 0)
                {
                    throw new IndexOutOfRangeException(
                        String.Format("{0} is too far back! There are only {1} bars",
                        index, count));
                }

                var bar = Bars[index];
                var value = Field.GetValue(bar);
                return (T)Convert.ChangeType(value, type);
            }
        }

        public T Value
        {
            get
            {
                return this[0];
            }
        }

        public BarSeries(IList<Bar> bars, string fieldName)
        {
            if (bars is null)
            {
                throw new ArgumentNullException("bars must not be null");
            }

            Bars = bars;
            Field = typeof(Bar).GetField(
                fieldName, BindingFlags.Public | BindingFlags.Instance);

            if (Field is null)
            {
                throw new ArgumentException(
                    string.Format("{0} is not a valid Bar field", fieldName));
            }
            
            if (Field.FieldType != type)
            {
                throw new ArgumentException(
                    string.Format("{0} is not the same type as {1}", fieldName, type));
            }
        }
    }
}
```
```
namespace MCRunner.Instruments
{
    public class Bars : IInstrument
    {
        public int CurrentBar
        {
            get
            {
                var index = bars.Count - 1;
                if (index < 0)
                {
                    throw new IndexOutOfRangeException();
                }

                return index;
            }
        }

        public IInstrumentSettings Info => throw new NotImplementedException();
        public IStatusLine StatusLine => throw new NotImplementedException();

        public double HighValue
        {
            get
            {
                return bars[CurrentBar].High;
            }
        }

        public double LowValue
        {
            get
            {
                return bars[CurrentBar].Low;
            }
        }

        public double OpenValue
        {
            get
            {
                return bars[CurrentBar].Open;
            }
        }

        public double CloseValue
        {
            get
            {
                return bars[CurrentBar].Close;
            }
        }

        public double VolumeValue
        {
            get
            {
                return bars[CurrentBar].Volume;
            }
        }

        public double TicksValue => throw new NotImplementedException();
        public double UpTicksValue => throw new NotImplementedException();
        public double DownTicksValue => throw new NotImplementedException();
        public double OpenIntValue => throw new NotImplementedException();

        public DateTime TimeValue
        {
            get
            {
                return bars[CurrentBar].Time;
            }
        }

        public DateTime LastBarTime
        {
            get
            {
                var lastBar = CurrentBar - 1;
                if (lastBar < 0)
                {
                    throw new IndexOutOfRangeException();
                }

                return bars[lastBar].Time;
            }
        }

        public bool LastBarOnChart => throw new NotImplementedException();
        public bool LastBarInSession => throw new NotImplementedException();
        public double Point => throw new NotImplementedException();
        public EBarState Status => throw new NotImplementedException();
        public IROList<SessionObject> Sessions => throw new NotImplementedException();
        public ISeriesSymbolDataRand FullSymbolData => throw new NotImplementedException();
        public IDOMData DOM => throw new NotImplementedException();
        public InstrumentDataRequest Request => throw new NotImplementedException();
        public DateTime BarUpdateTime => throw new NotImplementedException();
        public uint TickIDValue => throw new NotImplementedException();

        public ISeries<DateTime> Time { get; protected set; }
        public ISeries<double> High { get; protected set; }
        public ISeries<double> Low { get; protected set; }
        public ISeries<double> Open { get; protected set; }
        public ISeries<double> Close { get; protected set; }
        public ISeries<double> Volume { get; protected set; }
        public ISeries<double> Ticks => throw new NotImplementedException();
        public ISeries<double> UpTicks => throw new NotImplementedException();
        public ISeries<double> DownTicks => throw new NotImplementedException();
        public ISeries<double> OpenInt => throw new NotImplementedException();

        protected ImmutableList<Bar> bars = ImmutableList<Bar>.Empty;

        public Bars()
        {
            ReloadBarSeries();
        }

        public ImmutableList<IInstrument> ToSingleDataStream()
        {
            return ImmutableList<IInstrument>.Empty.Add(this);
        }

        protected void ReloadBarSeries()
        {
            Close = new BarSeries<double>(bars, "Close");
            High = new BarSeries<double>(bars, "High");
            Low = new BarSeries<double>(bars, "Low");
            Open = new BarSeries<double>(bars, "Open");
            Time = new BarSeries<DateTime>(bars, "Time");
            Volume = new BarSeries<double>(bars, "Volume");
        }
    }
}
```
```
namespace MCRunner.Instruments
{
    public interface IMonitoredInstrument : IInstrument
    {
        public event Action<Bar> Updated;
    }
}
```
```
namespace MCRunner.Instruments
{
    public class LoadableBars : Bars
    {
        public virtual void AddBar(Bar bar)
        {
            bars = bars.Add(bar);
            ReloadBarSeries();
        }
    }
}
```
```
namespace MCRunner.Instruments
{
    public class MonitoredBars : LoadableBars, IMonitoredInstrument
    {
        public event Action<Bar> Updated;

        public override void AddBar(Bar bar)
        {
            base.AddBar(bar);
            Updated.SafeTrigger(bar);
        }

        public new IEnumerable<IMonitoredInstrument> ToSingleDataStream()
        {
            return new List<IMonitoredInstrument> { this };
        }
    }
}
```
```
namespace MCRunner.Instruments
{
    public class PlayableBars : Bars
    {
        private IEnumerable<Bar> BarsToPlay { get; set; }

        public PlayableBars(IEnumerable<Bar> barsToPlay)
        {
            BarsToPlay = new List<Bar>(barsToPlay);
        }

        public void Play(Action action)
        {
            Play(bar => action());
        }

        public void Play(Action<Bar> action)
        {
            bars.Clear();

            foreach (var bar in BarsToPlay)
            {
                bars = bars.Add(bar);
                ReloadBarSeries();
                action(bar);
            }

            BarsToPlay = null;
        }
    }
}
```